pipeline {
    agent {
        docker {
            image 'demopq/robot-python-sele-chor:phuongttq'
            args '-u root'
        }
    }
    
    parameters {
        string(name: 'TASK_ID', defaultValue: '', description: 'Task ID from TestOps (e.g., TASK-001, PLAN-001, CICD-001)')
        choice(name: 'TASK_TYPE', choices: ['execution', 'plan', 'cicd'], description: 'Type of task')
    }
    
    environment {
        ROBOT_OPTIONS = "--outputdir results --timestampoutputs"
    }
    
    stages {
        stage('Setup') {
            steps {
                script {
                    echo "üöÄ Starting ${params.TASK_TYPE} task: ${params.TASK_ID}"
                    echo "üìã Task Type: ${params.TASK_TYPE}"
                    echo "üÜî Task ID: ${params.TASK_ID}"
                    
                    // T·∫°o th∆∞ m·ª•c results n·∫øu ch∆∞a c√≥
                    sh 'mkdir -p results'
                }
            }
        }
        
        stage('Run Robot Tests') {
            steps {
                script {
                    try {
                        // Ch·∫°y Robot Framework tests
                        sh '''
                            robot ${ROBOT_OPTIONS} Bases/Testcase/login.robot || true
                        '''
                        
                        echo "‚úÖ Robot tests completed"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Robot tests failed, but continuing..."
                        // V·∫´n ti·∫øp t·ª•c ƒë·ªÉ t·∫°o report
                    }
                }
            }
        }
        
        stage('Generate Report') {
            steps {
                script {
                    // Lu√¥n t·∫°o report, d√π test pass hay fail
                    try {
                        // Ki·ªÉm tra xem c√≥ file output.xml kh√¥ng
                        if (fileExists('results/output.xml')) {
                            echo "üìä Found output.xml, generating detailed report"
                            sh '''
                                robot --outputdir results --report results/report.html --log results/log.html results/output.xml || true
                            '''
                        } else {
                            echo "‚ö†Ô∏è No output.xml found, creating minimal report"
                            // T·∫°o file output.xml t·ªëi thi·ªÉu n·∫øu kh√¥ng c√≥
                            sh '''
                                cat > results/output.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<robot generator="Robot 6.0.2" generated="2024-01-01 00:00:00.000000" rpa="false" schemaversion="3">
<suite id="s1" name="Test Suite" source="test.robot">
<test id="s1-t1" name="Test Case">
<kw name="Log" library="BuiltIn">
<msg timestamp="20240101 00:00:00.000" level="INFO">Test execution completed</msg>
<status status="FAIL" starttime="20240101 00:00:00.000" endtime="20240101 00:00:01.000"></status>
</kw>
<status status="FAIL" starttime="20240101 00:00:00.000" endtime="20240101 00:00:01.000" critical="true">Test failed</status>
</test>
<status status="FAIL" starttime="20240101 00:00:00.000" endtime="20240101 00:00:01.000" critical="true"></status>
</suite>
<statistics>
<total>
<stat pass="0" fail="1" skip="0">All Tests</stat>
</total>
<tag>
</tag>
<suite>
<stat pass="0" fail="1" skip="0" id="s1" name="Test Suite">Test Suite</stat>
</suite>
</statistics>
<errors>
</errors>
</robot>
EOF
                            '''
                        }
                        
                        // T·∫°o file report.html n·∫øu ch∆∞a c√≥
                        if (!fileExists('results/report.html')) {
                            sh '''
                                robot --outputdir results --report results/report.html --log results/log.html results/output.xml || true
                            '''
                        }
                        
                        echo "‚úÖ Report generation completed"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Report generation failed: ${e.getMessage()}"
                        // V·∫´n ti·∫øp t·ª•c ƒë·ªÉ g·ª≠i webhook
                    }
                }
            }
        }
        
        stage('Archive Results') {
            steps {
                script {
                    try {
                        // N√©n t·∫•t c·∫£ k·∫øt qu·∫£
                        sh '''
                            tar czf results.tar.gz -C results .
                        '''
                        
                        // Archive artifacts
                        archiveArtifacts artifacts: 'results/**/*', fingerprint: true
                        archiveArtifacts artifacts: 'results.tar.gz', fingerprint: true
                        
                        echo "‚úÖ Results archived successfully"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Archive failed: ${e.getMessage()}"
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                def taskId = params.TASK_ID ?: ''
                def buildResult = currentBuild.result ?: 'UNKNOWN'
                def buildStatus = currentBuild.currentResult ?: 'UNKNOWN'
                
                echo "üìã Build Summary:"
                echo "  - Job Name: ${env.JOB_NAME}"
                echo "  - Build Number: ${env.BUILD_NUMBER}"
                echo "  - Build Result: ${buildResult}"
                echo "  - Build Status: ${buildStatus}"
                echo "  - Task ID: ${taskId}"
                echo "  - Task Type: ${params.TASK_TYPE}"
                
                // Chu·∫©n b·ªã webhook data
                def webhookData = [
                    name: env.JOB_NAME,
                    build: [
                        number: env.BUILD_NUMBER,
                        result: buildResult,
                        status: buildStatus,
                        timestamp: currentBuild.startTimeInMillis,
                        duration: currentBuild.duration
                    ]
                ]
                
                // Th√™m TASK_ID v√†o parameters n·∫øu c√≥
                if (taskId && taskId.trim()) {
                    webhookData.build.parameters = [TASK_ID: taskId]
                    echo "üîß Task ID included in webhook: ${taskId}"
                }
                
                // G·ª≠i webhook cho m·ªçi tr∆∞·ªùng h·ª£p (SUCCESS v√† FAILURE)
                try {
                    httpRequest(
                        url: 'http://backend:8000/api/reports/jenkins/webhook',
                        httpMode: 'POST',
                        contentType: 'APPLICATION_JSON',
                        requestBody: groovy.json.JsonOutput.toJson(webhookData),
                        validResponseCodes: '200,201,202'
                    )
                    echo "‚úÖ Webhook sent successfully for result: ${buildResult}"
                } catch (Exception e) {
                    echo "‚ùå Failed to send webhook: ${e.getMessage()}"
                }
                
                // C·∫≠p nh·∫≠t defaultValue cho CI/CD tasks
                if (params.TASK_TYPE == 'cicd' && taskId && taskId.trim()) {
                    try {
                        def configUrl = "${env.JENKINS_URL}/job/${env.JOB_NAME}/config.xml"
                        def configResponse = httpRequest(
                            url: configUrl,
                            httpMode: 'GET',
                            validResponseCodes: '200'
                        )
                        
                        if (configResponse.status == 200) {
                            def currentConfig = configResponse.content
                            
                            // C·∫≠p nh·∫≠t defaultValue cho TASK_ID
                            def updatedConfig = currentConfig.replaceAll(
                                /(<hudson\.model\.StringParameterDefinition>\s*<name>TASK_ID</name>.*?<trim>false<\/trim>)/,
                                """<hudson.model.StringParameterDefinition>
          <name>TASK_ID</name>
          <description>Task ID from TestOps (e.g., TASK-001, PLAN-001, CICD-001)</description>
          <defaultValue>${taskId}</defaultValue>
          <trim>false</trim>"""
                            )
                            
                            // G·ª≠i config ƒë√£ c·∫≠p nh·∫≠t v·ªÅ Jenkins
                            httpRequest(
                                url: configUrl,
                                httpMode: 'POST',
                                requestBody: updatedConfig,
                                contentType: 'APPLICATION_XML',
                                validResponseCodes: '200'
                            )
                            echo "‚úÖ Updated defaultValue for TASK_ID: ${taskId}"
                        }
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Could not update defaultValue: ${e.getMessage()}"
                    }
                }
            }
        }
        
        success {
            script {
                def successMessage = ''
                switch(params.TASK_TYPE) {
                    case 'execution':
                        successMessage = '‚úÖ Execution completed successfully'
                        break
                    case 'plan':
                        successMessage = '‚úÖ Scheduled plan completed successfully'
                        break
                    case 'cicd':
                        successMessage = '‚úÖ CI/CD pipeline completed successfully'
                        break
                }
                echo successMessage
                echo "üìä Report generated and sent to backend"
            }
        }
        
        failure {
            script {
                def failureMessage = ''
                switch(params.TASK_TYPE) {
                    case 'execution':
                        failureMessage = '‚ùå Execution failed'
                        break
                    case 'plan':
                        failureMessage = '‚ùå Scheduled plan failed'
                        break
                    case 'cicd':
                        failureMessage = '‚ùå CI/CD pipeline failed'
                        break
                }
                echo failureMessage
                echo "üìä Report still generated and sent to backend"
            }
        }
        
        cleanup {
            script {
                echo "üßπ Cleaning up workspace..."
                // C√≥ th·ªÉ th√™m cleanup logic ·ªü ƒë√¢y n·∫øu c·∫ßn
            }
        }
    }
}
